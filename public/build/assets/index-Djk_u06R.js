import{r as c,t as v}from"./app-DFZA_hNK.js";import{u as h}from"./index-CJ1Ro1aG.js";function w(e,n,{checkForDefaultPrevented:t=!0}={}){return function(o){if(e?.(o),t===!1||!o.defaultPrevented)return n?.(o)}}var b=v[" useInsertionEffect ".trim().toString()]||h;function m({prop:e,defaultProp:n,onChange:t=()=>{},caller:i}){const[o,s,f]=S({defaultProp:n,onChange:t}),r=e!==void 0,l=r?e:o;{const u=c.useRef(e!==void 0);c.useEffect(()=>{const d=u.current;d!==r&&console.warn(`${i} is changing from ${d?"controlled":"uncontrolled"} to ${r?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),u.current=r},[r,i])}const a=c.useCallback(u=>{if(r){const d=z(u)?u(e):u;d!==e&&f.current?.(d)}else s(u)},[r,e,s,f]);return[l,a]}function S({defaultProp:e,onChange:n}){const[t,i]=c.useState(e),o=c.useRef(t),s=c.useRef(n);return b(()=>{s.current=n},[n]),c.useEffect(()=>{o.current!==t&&(s.current?.(t),o.current=t)},[t,o]),[t,i,s]}function z(e){return typeof e=="function"}function C(e){const[n,t]=c.useState(void 0);return h(()=>{if(e){t({width:e.offsetWidth,height:e.offsetHeight});const i=new ResizeObserver(o=>{if(!Array.isArray(o)||!o.length)return;const s=o[0];let f,r;if("borderBoxSize"in s){const l=s.borderBoxSize,a=Array.isArray(l)?l[0]:l;f=a.inlineSize,r=a.blockSize}else f=e.offsetWidth,r=e.offsetHeight;t({width:f,height:r})});return i.observe(e,{box:"border-box"}),()=>i.unobserve(e)}else t(void 0)},[e]),n}export{C as a,w as c,m as u};
